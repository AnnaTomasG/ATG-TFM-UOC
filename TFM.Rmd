---
title: 'TFM'
author: "Anna Tomas Gasco"
output:
  pdf_document:
    number_sections: no
    toc: yes
    toc_depth: 3
  html_document:
    toc: yes
    toc_depth: 3
  word_document:
    toc: yes
    toc_depth: '3'
---
\pagebreak
```{r echo=FALSE}
#Debemos escribir este comando para que nos accepte las tildes. 
Sys.setenv(LANGUAGE="es")

```

\pagebreak



Llibreries
```{r echo=FALSE,warning=FALSE,message=FALSE}
#Cargamos las librerias que necesitaremos


library(knitr)
library(rlang)
library(class)

library(ggplot2)

library(stats)
library(lattice)
library(expss)

library(plyr)
library(sjmisc)
library(qwraps2)
library(factoextra)
library(lifecycle)
library(fpc)
library(NbClust)
library(curl)
library(cluster)

library(zip)

library(Rtsne)
library(dplyr)
library(mclust)
library(clustMixType)
library(bestNormalize)
library(tictoc)
library(patchwork)


set.seed(67637)

```


###Functions

S'ha creat una funció que calcula el percentatge de supervivencia quan li introdueixes la matriu de dades i el vector de clusters.


```{r echo=FALSE,warning=FALSE,message=FALSE}

get_pos_results<-function(df,cvect){
  

  for(i in 1:max(cvect)){
  
  alive_ind_total <- dim(df[df$DEATH_EVENT==0,])[1]
  cluster <- df[cvect==i,]
  ind_cluster <- dim(cluster)[1]
  alive_ind_cluster <- dim(cluster[cluster$DEATH_EVENT==0,])[1]
  
  
  percentage <- round((alive_ind_cluster/ind_cluster)*100,2)


  cat("Cluster number", i, "with a total of", ind_cluster, "individuals, has", alive_ind_cluster, "negative death events (", percentage, "% survival rate) \n")

  }
  
  
  }

```

Funció per fer diferentss estudis estratificats amb hkmeans

```{r message=FALSE, warning=FALSE}

study_hkmeans <- function(dfNumScaled,k,outliers=FALSE,title=FALSE,titleoutliers=FALSE){
  hk.res <- hkmeans(dfNumScaled, k)
  if(outliers != FALSE){
    dfNumScaledwoOutliers <- dfNumScaled[!(row.names(dfNumScaled) %in% outliers),]
    hk.reswoOutliers <- hkmeans(dfNumScaledwoOutliers, k)
    plot1 <- fviz_cluster(hk.res, palette = "jco", repel = TRUE, ggtheme = theme_classic(),main = title)
    plot2 <- fviz_cluster(hk.reswoOutliers, palette = "jco", repel = TRUE, ggtheme = theme_classic(),main = titleoutliers)
    plot1 + plot2
  }else{
    fviz_cluster(hk.res, palette = "jco", repel = TRUE, ggtheme = theme_classic(),main = title)
  }
}

```


Funció per calcular PAM amb Gower distance (Calcul Gower distance + càlcul PAM)
```{r message=FALSE, warning=FALSE}
study_gow_sil <- function(dfFactor, df,mink=2, maxk=10){
  gower_dist <- daisy(dfFactor, metric = "gower", stand=TRUE)
  
 # Calcula silhouette width per diferents k

  sil_width <- c(NA)

  for(i in mink:maxk){
  
  pam_fit <- pam(gower_dist, diss = TRUE, k = i)
  
  sil_width[i] <- pam_fit$silinfo$avg.width
  
  }

  plot((mink-1):maxk, sil_width,
      xlab = "Number of clusters",
      ylab = "Silhouette Width")
  lines((mink-1):maxk, sil_width)
  
  return_list=list(gower_dist,which(sil_width==max(sil_width,na.rm = T)))
  
  
  return(return_list)
}
```


Funció per representar PAM amb Gower distance

```{r message=FALSE, warning=FALSE}
study_pam_gow <- function(dfFactor, gow_dis,k,titulo=FALSE){
  res.pam <- pam(gow_dis, diss = TRUE, k)
  pam_results <- dfFactor %>%
    mutate(cluster = res.pam$clustering) %>%
    group_by(cluster) %>%
    do(the_summary = summary(.))
  pam_results$the_summary
  if(titulo==FALSE){
    clusplot(res.pam)
  }else{
    clusplot(res.pam, main = titulo)
  }
}
```





### Anàlisi exploratori

Primer carreguem les dades

```{r message=FALSE, warning=FALSE}

hf<-read.csv(file="C:/Users/Anna/Documents/Anna/UOC/TFM/Datasets/A_POSSIBLES/Heart Failure/heart_failure_clinical_records_dataset.csv",header = TRUE, sep = ",")


```


***

Exploració taula

```{r message=FALSE, warning=FALSE}

head(hf)

```

resum variables
```{r message=FALSE, warning=FALSE}

str(hf)


```

substituim els 0 i 1 per paraules en el vector del sexe per obtenir uns resultats més visuals de les taules de contingencia

S'ha de crear nnou data frame per no interferir amb el estudi de cluster****
```{r message=FALSE, warning=FALSE}



#hf$sex<-replace(hf$sex,hf$sex==0,"Female")
#hf$sex<-replace(hf$sex,hf$sex==1,"Male")
#hf$sex
#head(hf)


```


Construim una matriu amb les variables binaries com a factors per poder mostrar resultats més endavant

```{r message=FALSE, warning=FALSE}

head(hf)

hf_factor<-hf


hf_factor$anaemia<-as.factor(hf_factor$anaemia)

hf_factor$diabetes<-as.factor(hf_factor$diabetes)

hf_factor$high_blood_pressure<-as.factor(hf_factor$high_blood_pressure)

hf_factor$sex<-as.factor(hf_factor$sex)

hf_factor$smoking<-as.factor(hf_factor$smoking)

head(hf_factor)


```

Netejem dades

Comprovem si hi ha missing data

```{r message=FALSE, warning=FALSE}

hf[!complete.cases(hf),]
dim(hf)

hf <- na.omit(hf)

dim(hf)


```
 
### **1.Exploració dades categòriques**

grafics bivariants


```{r message=FALSE, warning=FALSE}

plot(hf)
plot(hf$ejection_fraction, hf$platelets)


```

Convertim la variable EF en un factor 

```{r message=FALSE, warning=FALSE}

#hf$EF<-cut(hf$ejection_fraction,c(0,40,50,100))

#hf$EF

hf$EF2<-cut(hf$ejection_fraction,c(0,40,50,100), labels = c("Reducida", "Limite", "Conservada"))
hf$EF2

hf$ejection_fraction

hf<-hf[,-14]

```




```{r message=FALSE, warning=FALSE}

plot(hf)


```


taules de contingencia

```{r message=FALSE, warning=FALSE}

hf=apply_labels(hf,
                sex="sex",
                sex=c("Female"=0,"Male"=1),
                anaemia="anemia",
                diabetes="diabetes",
                high_blood_pressure="hipertensio arterial",
                smoking="fumador")
# cro(hf$anaemia,hf$sex)
# cro(hf$diabetes,hf$sex)
# cro(hf$high_blood_pressure,hf$sex)
# cro(hf$smoking,hf$sex)

cro_rpct(hf$sex, list(hf$anaemia,hf$diabetes,hf$high_blood_pressure,hf$smoking))


# cro(hf$DEATH_EVENT,hf$sex)
# cro(hf$DEATH_EVENT,hf$smoking)
# 
# cro(hf$sex,hf$DEATH_EVENT)
# 
cro(hf$anaemia,hf$DEATH_EVENT,hf$sex)
cro(hf$diabetes,hf$DEATH_EVENT,hf$sex)
cro(hf$high_blood_pressure,hf$DEATH_EVENT,hf$sex)
cro(hf$smoking,hf$DEATH_EVENT,hf$sex)


cro_cpct(hf$DEATH_EVENT,hf$sex, list(hf$anaemia,hf$diabetes,hf$high_blood_pressure,hf$smoking))



```


Proba: agafo 2 mostres random de 100 homes i 100 dones per veure si hi ha diferencies ja que les poblacions d'homes i dones son molt diferents


```{r message=FALSE, warning=FALSE}

 normhf<-rbind(hf[sample(which(hf$sex==0),100),],hf[sample(which(hf$sex==1),100),])
# hf[sample(which(hf$sex==0),100),]
normhf


str(normhf)
```


taules de contingencia
```{r message=FALSE, warning=FALSE}

#  normhf=apply_labels(normhf,
#                 sex="sex",
#                 sex=c("Female"=0,"Male"=1),
#                 anaemia="anemia",
#                 diabetes="diabetes",
#                 high_blood_pressure="hipertensio arterial",
#                 smoking="fumador")



# cro(hf$anaemia,hf$sex)
# cro(hf$diabetes,hf$sex)
# cro(hf$high_blood_pressure,hf$sex)
# cro(hf$smoking,hf$sex)

cro_rpct(normhf$sex, list(normhf$anaemia,normhf$diabetes,normhf$high_blood_pressure,normhf$smoking))


# cro(hf$DEATH_EVENT,hf$sex)
# cro(hf$DEATH_EVENT,hf$smoking)
# 
# cro(hf$sex,hf$DEATH_EVENT)
# 
cro(hf$anaemia,hf$DEATH_EVENT,hf$sex)
cro(hf$diabetes,hf$DEATH_EVENT,hf$sex)
cro(hf$high_blood_pressure,hf$DEATH_EVENT,hf$sex)
cro(hf$smoking,hf$DEATH_EVENT,hf$sex)


cro_cpct(hf$DEATH_EVENT,hf$sex, list(hf$anaemia,hf$diabetes,hf$high_blood_pressure,hf$smoking))



```



Prova: agafo 2 mostres random de 50 homes i 50 dones per veure si hi ha diferencies 


```{r message=FALSE, warning=FALSE}

 normhf50<-rbind(hf[sample(which(hf$sex==0),50),],hf[sample(which(hf$sex==1),50),])
# hf[sample(which(hf$sex==0),100),]
normhf50


str(normhf50)
```


taules de contingencia
```{r message=FALSE, warning=FALSE}

#  normhf=apply_labels(normhf,
#                 sex="sex",
#                 sex=c("Female"=0,"Male"=1),
#                 anaemia="anemia",
#                 diabetes="diabetes",
#                 high_blood_pressure="hipertensio arterial",
#                 smoking="fumador")



# cro(hf$anaemia,hf$sex)
# cro(hf$diabetes,hf$sex)
# cro(hf$high_blood_pressure,hf$sex)
# cro(hf$smoking,hf$sex)

cro_rpct(normhf50$sex, list(normhf50$anaemia,normhf50$diabetes,normhf50$high_blood_pressure,normhf50$smoking))


# cro(hf$DEATH_EVENT,hf$sex)
# cro(hf$DEATH_EVENT,hf$smoking)
# 
# cro(hf$sex,hf$DEATH_EVENT)
# 
cro(hf$anaemia,hf$DEATH_EVENT,hf$sex)
cro(hf$diabetes,hf$DEATH_EVENT,hf$sex)
cro(hf$high_blood_pressure,hf$DEATH_EVENT,hf$sex)
cro(hf$smoking,hf$DEATH_EVENT,hf$sex)


cro_cpct(hf$DEATH_EVENT,hf$sex, list(hf$anaemia,hf$diabetes,hf$high_blood_pressure,hf$smoking))



```
Una manera de representar les taules de contingencia

```{r message=FALSE, warning=FALSE}

head(hf)

#Bar charts stacked
ggplot(hf,aes(x=anaemia, fill=sex) )+ geom_bar()
ggplot(hf,aes(x=diabetes, fill=sex) )+ geom_bar()
ggplot(hf,aes(x=high_blood_pressure, fill=sex) )+ geom_bar()
ggplot(hf,aes(x=smoking, fill=sex) )+ geom_bar()
ggplot(hf,aes(x=DEATH_EVENT, fill=sex) )+ geom_bar()

ggplot(hf,aes(x=DEATH_EVENT, fill=EF2) )+ geom_bar()




#Bar charts not stacked
ggplot(hf,aes(x=anaemia, fill=sex) )+ geom_bar(position = "dodge")
ggplot(hf,aes(x=diabetes, fill=sex) )+ geom_bar(position = "dodge")
ggplot(hf,aes(x=high_blood_pressure, fill=sex) )+ geom_bar(position = "dodge")
ggplot(hf,aes(x=smoking, fill=sex) )+ geom_bar(position = "dodge")
ggplot(hf,aes(x=DEATH_EVENT, fill=sex) )+ geom_bar(position = "dodge")


ggplot(hf,aes(x=DEATH_EVENT, fill=EF2) )+ geom_bar(position = "dodge")



```

Mostrant les proporcions de manera gràfica


```{r message=FALSE, warning=FALSE}

ggplot(hf,aes(x=anaemia, fill=sex) )+ geom_bar(position = "fill") + ylab("proportion")
ggplot(hf,aes(x=diabetes, fill=sex) )+ geom_bar(position = "fill") + ylab("proportion")
ggplot(hf,aes(x=high_blood_pressure, fill=sex) )+ geom_bar(position = "fill") + ylab("proportion")
ggplot(hf,aes(x=smoking, fill=sex) )+ geom_bar(position = "fill") + ylab("proportion")
ggplot(hf,aes(x=DEATH_EVENT, fill=sex) )+ geom_bar(position = "fill") + ylab("proportion")

ggplot(hf,aes(x=DEATH_EVENT, fill=EF2) )+ geom_bar(position = "fill") + ylab("proportion")


```


Distribucions per a una variable (marginal distribution)
```{r message=FALSE, warning=FALSE}
#distribució per a les variables
ggplot(hf,aes(x=anaemia) )+ geom_bar()


#distribució segons sexe
ggplot(hf,aes(x=anaemia) )+ geom_bar()+facet_wrap(~sex)
ggplot(hf,aes(x=diabetes) )+ geom_bar()+facet_wrap(~sex)
ggplot(hf,aes(x=high_blood_pressure) )+ geom_bar()+facet_wrap(~sex)
ggplot(hf,aes(x=smoking) )+ geom_bar()+facet_wrap(~sex)
ggplot(hf,aes(x=DEATH_EVENT) )+ geom_bar()+facet_wrap(~sex)
ggplot(hf,aes(x=DEATH_EVENT) )+ geom_bar()


ggplot(hf,aes(x=DEATH_EVENT) )+ geom_bar()+facet_wrap(~EF2)

ggplot(hf,aes(x=EF2) )+ geom_bar()+facet_wrap(~DEATH_EVENT)

```

### **2. Exploració Dades numériques**

Faceted histogram

```{r message=FALSE, warning=FALSE}
head(hf)

ggplot(hf, aes(x = age)) +
  geom_histogram() +
  facet_wrap(~ sex)

ggplot(hf, aes(x = creatinine_phosphokinase )) +
  geom_histogram() +
  facet_wrap(~ sex)


ggplot(hf, aes(x = ejection_fraction )) +
  geom_histogram() +
  facet_wrap(~ sex)

ggplot(hf, aes(x = platelets )) +
  geom_histogram() +
  facet_wrap(~ sex)

ggplot(hf, aes(x = serum_creatinine )) +
  geom_histogram() +
  facet_wrap(~ sex)

ggplot(hf, aes(x = serum_sodium )) +
  geom_histogram() +
  facet_wrap(~ sex)


```

Perfils similars

Plaquetes augmentar en resposta a una inflamació, anèmia per dèficit de ferro

trobar mes convinacions per trobar discrepancies
```{r message=FALSE, warning=FALSE}
ggplot(hf, aes(x = platelets )) +
  geom_histogram() +
  facet_wrap(~ anaemia)



ggplot(hf, aes(x = serum_sodium )) +
  geom_histogram() +
  facet_wrap(~ anaemia)

ggplot(hf, aes(x = creatinine_phosphokinase )) +
  geom_histogram() +
  facet_wrap(~ anaemia)


ggplot(hf, aes(x = age )) +
  geom_histogram() +
  facet_wrap(~ anaemia)



ggplot(hf, aes(x = ejection_fraction )) +
  geom_histogram() +
  facet_wrap(~ anaemia)



ggplot(hf, aes(x = age )) +
  geom_histogram() +
  facet_wrap(~ anaemia)

```

Boxplots

```{r message=FALSE, warning=FALSE}


boxplot(hf_varcont)


boxplot(hf_varcont[,-c(4,2)])


boxplot(hf_varcont[,4])
boxplot(hf_varcont[,2])

boxplot(hf_varcont[,5])

for(i in 1:dim(hf)[2]){
  boxplot(hf[,i])
  title(names(hf)[i])
}

out_crephos<-boxplot.stats(hf$creatinine_phosphokinase)$out
out_crephos_ind<-which(hf$creatinine_phosphokinase %in% c(out_crephos))
hf[out_crephos_ind,]
summary(hf[out_crephos_ind,])

#anemia boxplots

ggplot(hf_factor, aes(x = hf_factor$anaemia, y = hf_factor$ejection_fraction)) +
  geom_boxplot()

ggplot(hf_factor, aes(x = hf_factor$anaemia, y = hf_factor$age)) +
  geom_boxplot()
ggplot(hf_factor, aes(x = hf_factor$anaemia, y = hf_factor$creatinine_phosphokinase)) +
  geom_boxplot()



ggplot(hf_factor, aes(x = hf_factor$anaemia, y = hf_factor$platelets)) +
  geom_boxplot()


ggplot(hf_factor, aes(x = hf_factor$anaemia, y = hf_factor$serum_creatinine)) +
  geom_boxplot()
ggplot(hf_factor, aes(x = hf_factor$anaemia, y = hf_factor$serum_sodium)) +
  geom_boxplot()



ggplot(hf, aes(x = hf$ejection_fraction, fill = as.factor(hf$anaemia))) +
  geom_density(alpha = .2)

ggplot(hf, aes(x = hf$age, fill = as.factor(hf$anaemia))) +
  geom_density(alpha = .2)



ggplot(hf, aes(x = hf$age, fill = as.factor(hf$high_blood_pressure))) +
  geom_density(alpha = .2)


head(hf)



ggplot(hf, aes(x = hf$age, fill = as.factor(hf$high_blood_pressure))) +
  geom_density(alpha = .2)


#densitat death event (interesant)


ggplot(hf, aes(x = hf$creatinine_phosphokinase, fill = as.factor(hf$DEATH_EVENT))) +
  geom_density(alpha = .2)

ggplot(hf, aes(x = hf$age, fill = as.factor(hf$DEATH_EVENT))) +
  geom_density(alpha = .2)


ggplot(hf, aes(x = hf$serum_sodium, fill = as.factor(hf$DEATH_EVENT))) +
  geom_density(alpha = .2)

ggplot(hf, aes(x = hf$ejection_fraction, fill = as.factor(hf$DEATH_EVENT))) +
  geom_density(alpha = .2)


ggplot(hf, aes(x = hf$platelets, fill = as.factor(hf$DEATH_EVENT))) +
  geom_density(alpha = .2)

ggplot(hf, aes(x = hf$serum_creatinine, fill = as.factor(hf$DEATH_EVENT))) +
  geom_density(alpha = .2)

ggplot(hf, aes(x = hf$time, fill = as.factor(hf$DEATH_EVENT))) +
  geom_density(alpha = .2)


#densitat Sex (no diu res)

ggplot(hf, aes(x = hf$creatinine_phosphokinase, fill = as.factor(hf$sex))) +
  geom_density(alpha = .2)

ggplot(hf, aes(x = hf$age, fill = as.factor(hf$sex))) +
  geom_density(alpha = .2)


ggplot(hf, aes(x = hf$serum_sodium, fill = as.factor(hf$sex))) +
  geom_density(alpha = .2)

ggplot(hf, aes(x = hf$ejection_fraction, fill = as.factor(hf$sex))) +
  geom_density(alpha = .2)


ggplot(hf, aes(x = hf$platelets, fill = as.factor(hf$sex))) +
  geom_density(alpha = .2)

ggplot(hf, aes(x = hf$serum_creatinine, fill = as.factor(hf$sex))) +
  geom_density(alpha = .2)

ggplot(hf, aes(x = hf$time, fill = as.factor(hf$sex))) +
  geom_density(alpha = .2)


#altres comparacions


ggplot(hf, aes(x = hf$platelets, fill = as.factor(hf$anaemia))) +
  geom_density(alpha = .2) #No s'observa gran relacio entre les variables


ggplot(hf, aes(x = hf$serum_sodium, fill = as.factor(hf$high_blood_pressure))) +
  geom_density(alpha = .2) #No s'observa gran relacio entre les variables




```


**PCA**

```{r message=FALSE, warning=FALSE}


hfNscaled2<-hfNscaled[,-5]

head(hfNscaled2)


```



```{r message=FALSE, warning=FALSE}

res.pca <- prcomp(hfNscaled)
# Visualize eigenvalues/variances
fviz_screeplot(res.pca, addlabels = TRUE, ylim = c(0, 50))


# Extract the results for variables
var <- get_pca_var(res.pca)
# Contributions of variables to PC1
fviz_contrib(res.pca, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(res.pca, choice = "var", axes = 2, top = 10)
# Control variable colors using their contributions to the principle axis
fviz_pca_var(res.pca, col.var="contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping
             ) + theme_minimal() + ggtitle("Variables - PCA")






```

Sense observacio 10
```{r message=FALSE, warning=FALSE}

res.pca <- prcomp(hfNscaledNew)
# Visualize eigenvalues/variances
fviz_screeplot(res.pca, addlabels = TRUE, ylim = c(0, 50))


# Extract the results for variables
var <- get_pca_var(res.pca)
# Contributions of variables to PC1
fviz_contrib(res.pca, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(res.pca, choice = "var", axes = 2, top = 10)
# Control variable colors using their contributions to the principle axis
fviz_pca_var(res.pca, col.var="contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping
             ) + theme_minimal() + ggtitle("Variables - PCA")






```


Sense variable serum creatinine


```{r message=FALSE, warning=FALSE}

res.pca <- prcomp(hfNscaled2)
# Visualize eigenvalues/variances
fviz_screeplot(res.pca, addlabels = TRUE, ylim = c(0, 50))


# Extract the results for variables
var <- get_pca_var(res.pca)
# Contributions of variables to PC1
fviz_contrib(res.pca, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(res.pca, choice = "var", axes = 2, top = 10)
# Control variable colors using their contributions to the principle axis
fviz_pca_var(res.pca, col.var="contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping
             ) + theme_minimal() + ggtitle("Variables - PCA")






```







```{r message=FALSE, warning=FALSE}

summary(hf)


boxplot(hf$serum_creatinine, main="Creatinina en Sang")#Te molts outliers en la part alta

boxplot(hf$serum_sodium, main="Sodi en Sang")

boxplot(hf$time, main="Temps de seguiment")



```










###Preparem dades per fer anàlisi de clusters

Escalem variables (a cada observació li resta la mitjana i la divideix per la desviació estandard)

s'ha de fer ja que les variables estan mesurades en escales molt diferents.

```{r message=FALSE, warning=FALSE}

hfscaled<-scale(hf)
head(hfscaled)

```


S'han d'utilitzar només les variables numériques en alguns casos. Treiem les binaries.


```{r message=FALSE, warning=FALSE}

hfNscaled<-hfscaled[,-c(2,4,6,10,11,13)]
head(hfNscaled)

```





###Anàlisi de clusters amb tota la matriu



Tendència a formar clusters VAT (The Visual Assessment of cluster tendency)

```{r message=FALSE, warning=FALSE}

get_clust_tendency(hfN, n=50)

get_clust_tendency(hfNscaled, n=50)

```
En els dos casos el estadístic de Hopkins dòna un valor proper a 1, el que significa que el nostre dataset té tendència a formar clusters.

El gràfic mostra alguns blocs més foscos a la diagonal però petits i dispersos. (plot for ordered dissimilarity image. This is generated using the function fviz_dist(dist.obj))

**Hopkins statistic: If the value of Hopkins statistic is close to 1 (far above 0.5), then we can conclude that the dataset is significantly clusterable.**

**VAT (Visual Assessment of cluster Tendency): The VAT detects the clustering tendency in a visual form by counting the number of square shaped dark (or colored) blocks along the diagonal in a VAT image.**

***



#### **1. k-means**

S'utilitzen les variables nomès numèriques i escalades



**PROVA***

**Calculem k-means utilitzant funció kmeans()**


k=3
```{r message=FALSE, warning=FALSE}

fitK<-kmeans(hfNscaled,3,nstart=50)

fitK

#plot(hf, col=fitK$cluster)

get_pos_results(hf,fitK$cluster)

```



Probem k-means per diferents valors de k, mostrem summary per cada cluster en cada moment per poder veure les característiques de les variables en cada cluster.

```{r message=FALSE, warning=FALSE}

for(k in 1:5){
  
  fitK <- kmeans(hfNscaled,k,nstart=50)
  
  cat("k =", k,"\n")
  
  get_pos_results(hf,fitK$cluster)
  
  
  for(c in 1:k){
    cat("Cluster =",c,"\n")
    print(summary(hf[fitK$cluster==c,]))
    
  }
}



```


***

**Trobem el número de clusters òptim**

Trobem la k adequada amb un **for**:

representem betweenss/totss

betweenss:  is the average of the square distances between the centroids
totss: The total sum of squares ($tot.withinss + $betweenss), variabilitat total


```{r message=FALSE, warning=FALSE}

k<-list()
for(i in 1:20){
  k[[i]]<-kmeans(hfNscaled,i)
}


betweenss_totss<-list()
for(i in 1:20){
  betweenss_totss[[i]]<-k[[i]]$betweenss/k[[i]]$totss
  
}

plot(1:20,betweenss_totss, type="b", ylab="Between SS / Total SS", xlab="Clusters(k)")
```


Quina es la k adequada? 4, pero no es veu molt clar


Realitzem un altre gràfic utilitzant el valor de **total within-cluster sum of square (WSS)**
WWS, mesura com de compcates son els clusters, es vol que sigui el mes petit possible, el que significara que son molt compactes.

Aquest metode s'anomena Elbow method.

```{r message=FALSE, warning=FALSE}
# Elbow method
fviz_nbclust(hfNscaled, kmeans, method = "wss") +
    geom_vline(xintercept = 4, linetype = 2)+
  labs(subtitle = "Elbow method")

```


Average Silhouette method: mesura la qualitat del cluster veient com de bé està classificada cada observació en el seu cluster, volem que l'index es maximitzi

```{r message=FALSE, warning=FALSE}
# Silhouette method
fviz_nbclust(hfNscaled, kmeans, method = "silhouette")+
  labs(subtitle = "Silhouette method")

```


Gap statistic method

```{r message=FALSE, warning=FALSE}

# Gap statistic

set.seed(123)
fviz_nbclust(hfNscaled, kmeans, nstart = 25,  method = "gap_stat", nboot = 100)+
  labs(subtitle = "Gap statistic method")

```
Elbow method, Silhouette method i Gap statistic donen resultats molt dispars, escollim k=4


reultats per k=4


```{r message=FALSE, warning=FALSE}

fitK<-kmeans(hfNscaled,4,nstart=50)

#fitK

#plot(hf, col=fitK$cluster)

#grafic

fviz_cluster(fitK,data=hfNscaled, geom = "point", ellipse.type = "norm", palette= "jco", ggtheme = theme_minimal())+labs(subtitle = "k-means")


```
***


**Calculem k-means utilitzant funció eclust()** **I es realitza la validació dels clusters**

També es pot calcular k-means amb la funció eclust().


k=4

```{r message=FALSE, warning=FALSE}

#K-means algorithm

km.res<-eclust(hfNscaled, "kmeans", k=4, nstart=50, graph = F )

#Clustering visualization

fviz_cluster(km.res, geom = "point", ellipse.type = "norm", palette= "jco", ggtheme = theme_minimal())
```

**External clustering Validation**

```{r message=FALSE, warning=FALSE}


#cross-tabulation entre k-means i variable death_event (EXTERNAL CLUSTERING VALIDATION)

table(hf$DEATH_EVENT, km.res$cluster)


#Corrected Rand index (EXTERNAL CLUSTERING VALIDATION)


clust_stats <- cluster.stats(d = dist(hfNscaled), 
                             hf$DEATH_EVENT, km.res$cluster)


clust_stats$corrected.rand

clust_stats$vi

```

Rand index: Its range is -1 (no agreement) to 1 (perfect agreement). 






Silhouette plot per clustering validation (Numeric variables, k-means)


```{r message=FALSE, warning=FALSE}
require("cluster")

sil<-silhouette(km.res$cluster,dist(hfNscaled))

fviz_silhouette(sil,label=FALSE,print.summary = FALSE)

#get_pos_results(hf,km.res$cluster)

```



**Calculem els clusters per diferents k amb la funció eclust (Num variables, variables escalades)**

```{r message=FALSE, warning=FALSE}

for(i in 2:10){
  
  km.res<-eclust(hfNscaled, "kmeans", k=i, nstart=25, graph = F )

  print(fviz_cluster(km.res, geom = "point", ellipse.type = "norm", palette= "jco", ggtheme = theme_minimal()))

  require("cluster")
  
  sil <- silhouette(km.res$cluster,dist(hfNscaled))

  print(fviz_silhouette(sil,label=FALSE,print.summary = FALSE))
  
  cat("k =", i,"\n")

  get_pos_results(hf,km.res$cluster)
  
  #cross-tabulation entre k-means i variable death_event (EXTERNAL CLUSTERING VALIDATION)
  
  print(table(hf$DEATH_EVENT, km.res$cluster))
 
#Corrected Rand index (EXTERNAL CLUSTERING VALIDATION)


clust_stats <- cluster.stats(d = dist(hfNscaled), 
                             hf$DEATH_EVENT, km.res$cluster)


print(clust_stats$corrected.rand)

print(clust_stats$vi)
    
  }


```






**Utilitzem la funció NbClust() per calcular 30 index que ens ajudarán a obtenir el número òptim de clusters**
```{r message=FALSE, warning=FALSE}

res<-NbClust(hfNscaled, diss=NULL, distance = "euclidean", min.nc=2, max.nc=10, method = "kmeans", index = "alllong")



barplot(table(res$Best.n[1,]),
              xlab="Numer of Clusters", ylab="Number of Criteria",
                    main="Number of Clusters Chosen by 28 Criteria")
table(res$Best.n[1,])


```
Suggereix k=2

```{r message=FALSE, warning=FALSE}
set.seed(1234)
fit.km <- kmeans(hfNscaled, 2, nstart=25)

ct.km <- table(hf$DEATH_EVENT, fit.km$cluster)
ct.km  

library(flexclust)
randIndex(ct.km)

```

**FINAL DE LA PROVA**

***



**SEQUENCIA FINAL**

Matriu numèrica i escalada

**Utilitzem la funció NbClust() per calcular 30 index que ens ajudarán a obtenir el número òptim de clusters**

```{r message=FALSE, warning=FALSE}

#head(hfNscaled)

resk<-NbClust(hfNscaled, diss=NULL, distance = "euclidean", min.nc=2, max.nc=10, method = "kmeans", index = "alllong")



barplot(table(resk$Best.n[1,]),
              xlab="Numer of Clusters", ylab="Number of Criteria",
                    main="Number of Clusters for k-means")
table(resk$Best.n[1,])


```
Suggereix k=2


No es veu clar amb el Elbow method
```{r message=FALSE, warning=FALSE}
fviz_nbclust(hfNscaled, kmeans, method = "wss")


```


Calculem kmeans per k=2
```{r message=FALSE, warning=FALSE}
set.seed(67637)


km.res <- kmeans(hfNscaled, 2, nstart = 50)



```

Calculem mitjanes de les variables en cada cluster per veure diferències inicials. 
```{r message=FALSE, warning=FALSE}
aggregate(hf, by=list(cluster=km.res$cluster), mean)

```

Representem els resultats utilitzant les 2 primeres PCA

```{r message=FALSE, warning=FALSE}


fviz_cluster(km.res, data = hfNscaled,
palette = c( "#E7B800", "#FC4E07"),
ellipse.type = "convex", # Concentration ellipse
star.plot = FALSE, # Add segments from centroids to items
repel = TRUE, # Avoid label overplotting (slow)
ggtheme = theme_minimal()
)




```




#### **2.1 Clustering jerarquic - Agglomerative**

Les dades han de ser numériques i han d'estar escalades:






Aplico NbClust() per veure quin k és el més adequat i on s'haurà de tallar lel dendograma.

**Utilitzem la funció NbClust() per calcular 30 index que ens ajudarán a obtenir el número òptim de clusters**



```{r message=FALSE, warning=FALSE}

tic("NbClust-hclust-alllong")
reshc<-NbClust(hfNscaled, diss=NULL, distance = "euclidean", min.nc=2, max.nc=10, method = "ward.D2", index = "alllong")



barplot(table(reshc$Best.n[1,]),
              xlab="Numer of Clusters", ylab="Number of Criteria",
                    main="Number of Clusters for hclust")


table(reshc$Best.n[1,])




toc()
```
(amb "all" surt 3 clusters)

```{r message=FALSE, warning=FALSE}

res<-NbClust(hfNscaled, diss=NULL, distance = "euclidean", min.nc=2, max.nc=10, method = "average", index = "alllong")



barplot(table(res$Best.n[1,]),
              xlab="Numer of Clusters", ylab="Number of Criteria",
                    main="Number of Clusters Chosen by 29 Criteria")
table(res$Best.n[1,])


```


Després calculem els clusters amb la funció hclust (), compararem els 2 mètodes d'aglomeració més comuns i compararem els resultats **ward.D2** i **average**.


Primer es calculen les distàncies, utilitzem la fòrmula de la distància euclidea. 


```{r message=FALSE, warning=FALSE}

distancies<-dist(hfNscaled, method="euclidean")

```

Prova: Clusters matriu no escalada - Separa per la variable Platelets (Plaquetes), que es la variable més gran, no és útil

```{r message=FALSE, warning=FALSE}

#clusterH<-hclust(distancies, method = "ward")

#plot(clusterH)

```

```{r message=FALSE, warning=FALSE}
#clustergrups<-cutree(clusterH, k=5)

#plot(hf, col=clustergrups)

```


**Ward**

```{r message=FALSE, warning=FALSE}

res.hc1<-hclust(distancies, method = "ward.D2")

#plot(res.hc1)
#rect.hclust(res.hc1, k=2, border = "red")


fviz_dend(res.hc1, k = 2, # Cut in four groups
cex = 0.2, # label size
k_colors = c("#00AFBB", "#E7B800"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE, # Add rectangle around groups
main= "Cluster Dendogram (ward.D2)"
)




fviz_dend(res.hc1, k = 3, # Cut in four groups
cex = 0.2, # label size
k_colors = c("#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE, # Add rectangle around groups
main= "Cluster Dendogram (ward.D2)"
)

```


Scatterplot

```{r message=FALSE, warning=FALSE}

#tallem el dendograma per obtenir els clusters
#k=2
groups<- cutree(res.hc1, k = 2)


fviz_cluster(list(data =hfNscaled , cluster = groups),
palette = c("#E7B800", "#FC4E07"),
ellipse.type = "convex", # Concentration ellipse
repel = TRUE, # Avoid label overplotting (slow)
show.clust.cent = FALSE, ggtheme = theme_minimal())




#k=3 (CLUSTERS SOLAPATS)
groups<- cutree(res.hc1, k = 3)


fviz_cluster(list(data =hfNscaled , cluster = groups),
palette = c("#00AFBB","#E7B800", "#FC4E07"),
ellipse.type = "convex", # Concentration ellipse
repel = TRUE, # Avoid label overplotting (slow)
show.clust.cent = FALSE, ggtheme = theme_minimal())



```

Verifiquem el dendograma comparant les distancies calculades per la funció dist() amb les distancies cophenetic (altura del dendograma quan dues branques es junten amb una sola)


```{r message=FALSE, warning=FALSE}
res.coph <- cophenetic(res.hc1)


cor(distancies, res.coph)

```
S'obté un valor baix. Comença a ser un bon resultat a partir de 0.75. No hi ha correlació entre el arbre i les distancies en la matriu inicial de dades.


**Average NO SURT BE**


```{r message=FALSE, warning=FALSE}

res.hc2<-hclust(distancies, method = "centroid")

#plot(res.hc1)
#rect.hclust(res.hc1, k=2, border = "red")



fviz_dend(res.hc2, k = 2, # Cut in two groups
cex = 0.2, # label size
k_colors = c("#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE, # Add rectangle around groups
main= "Cluster Dendogram (average)"
)


```


Scatterplot

```{r message=FALSE, warning=FALSE}

#tallem el dendograma per obtenir els clusters
#k=2
groups<- cutree(res.hc2, k = 2)


fviz_cluster(list(data =hfNscaled , cluster = groups),
palette = c("#E7B800", "#FC4E07"),
ellipse.type = "convex", # Concentration ellipse
repel = TRUE, # Avoid label overplotting (slow)
show.clust.cent = FALSE, ggtheme = theme_minimal())





```


**Possibles outliers:**

```{r message=FALSE, warning=FALSE}

summary(hf)

hf[10,]

hf[297,]

hf[296,]

boxplot(hf$serum_creatinine)



```




Tornem a fer els calculs de hclust sense l'observació 10 i 296

```{r message=FALSE, warning=FALSE}

hfNscaledNew<-hfNscaled[-c(10),]
```


```{r message=FALSE, warning=FALSE}

distanciesNew<-dist(hfNscaledNew, method="euclidean")

distancies2<-dist(hfNscaled2, method="euclidean")

```


**Average NEW**
Mateixos resultats amb complete, single and centroid (amb i sense outliers)

```{r message=FALSE, warning=FALSE}

res.hc2<-hclust(distanciesNew, method = "average")



fviz_dend(res.hc2, k = 2, # Cut in four groups
cex = 0.2, # label size
k_colors = c("#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE, # Add rectangle around groups
main= "Cluster Dendogram (average)"
)


```


Scatterplot

```{r message=FALSE, warning=FALSE}

#tallem el dendograma per obtenir els clusters
#k=2
groups<- cutree(res.hc2, k = 2)


fviz_cluster(list(data =hfNscaledNew , cluster = groups),
palette = c("#00AFBB","#E7B800", "#FC4E07"),
ellipse.type = "convex", # Concentration ellipse
repel = TRUE, # Avoid label overplotting (slow)
show.clust.cent = FALSE, ggtheme = theme_minimal())





```


**Ward NEW**

```{r message=FALSE, warning=FALSE}

res.hc1<-hclust(distanciesNew, method = "ward.D2")



fviz_dend(res.hc1, k = 2, # Cut in four groups
cex = 0.2, # label size
k_colors = c("#00AFBB", "#E7B800"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE, # Add rectangle around groups
main= "Cluster Dendogram (ward.D2)"
)




fviz_dend(res.hc1, k = 3, # Cut in four groups
cex = 0.2, # label size
k_colors = c("#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE, # Add rectangle around groups
main= "Cluster Dendogram (ward.D2)"
)

```


Scatterplot

```{r message=FALSE, warning=FALSE}

#tallem el dendograma per obtenir els clusters
#k=2
groups<- cutree(res.hc1, k = 2)


fviz_cluster(list(data =hfNscaledNew , cluster = groups),
palette = c("#E7B800", "#FC4E07"),
ellipse.type = "convex", # Concentration ellipse
repel = TRUE, # Avoid label overplotting (slow)
show.clust.cent = FALSE, ggtheme = theme_minimal())




#k=3 (CLUSTERS SOLAPATS)
groups<- cutree(res.hc1, k = 3)


fviz_cluster(list(data =hfNscaledNew , cluster = groups),
palette = c("#00AFBB","#E7B800", "#FC4E07"),
ellipse.type = "convex", # Concentration ellipse
repel = TRUE, # Avoid label overplotting (slow)
show.clust.cent = FALSE, ggtheme = theme_minimal())



```




Donat que el methode average no dona bons resultats ja que un dels clusters nomes conté 3 observacions podem veure les diferencies obtingudes entre els dendogrames obtinguts amb i sense el "outlier" (NO ES POT NO TENEN DIMENSIONS IGUALS)



**Average (sense serum creatinine)** SOBTENEN RESULTATS MOLT PITJORS


```{r message=FALSE, warning=FALSE}

res.hc2<-hclust(distancies2, method = "average")



fviz_dend(res.hc2, k = 2, # Cut in four groups
cex = 0.2, # label size
k_colors = c("#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE, # Add rectangle around groups
main= "Cluster Dendogram (average)"
)


```


Scatterplot

```{r message=FALSE, warning=FALSE}

#tallem el dendograma per obtenir els clusters
#k=2
groups<- cutree(res.hc2, k = 2)


fviz_cluster(list(data =hfNscaled2 , cluster = groups),
palette = c("#00AFBB","#E7B800", "#FC4E07"),
ellipse.type = "convex", # Concentration ellipse
repel = TRUE, # Avoid label overplotting (slow)
show.clust.cent = FALSE, ggtheme = theme_minimal())





```


**Ward 2 (sense serum creatinine)** SOBTENEN RESULTATS MOLT PITJORS

```{r message=FALSE, warning=FALSE}

res.hc1<-hclust(distancies2, method = "ward.D2")



fviz_dend(res.hc1, k = 2, # Cut in four groups
cex = 0.2, # label size
k_colors = c("#00AFBB", "#E7B800"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE, # Add rectangle around groups
main= "Cluster Dendogram (ward.D2)"
)




fviz_dend(res.hc1, k = 3, # Cut in four groups
cex = 0.2, # label size
k_colors = c("#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE, # Add rectangle around groups
main= "Cluster Dendogram (ward.D2)"
)

```


Scatterplot

```{r message=FALSE, warning=FALSE}

#tallem el dendograma per obtenir els clusters
#k=2
groups<- cutree(res.hc1, k = 2)


fviz_cluster(list(data =hfNscaled2 , cluster = groups),
palette = c("#E7B800", "#FC4E07"),
ellipse.type = "convex", # Concentration ellipse
repel = TRUE, # Avoid label overplotting (slow)
show.clust.cent = FALSE, ggtheme = theme_minimal())




#k=3 (CLUSTERS SOLAPATS)
groups<- cutree(res.hc1, k = 3)


fviz_cluster(list(data =hfNscaled2 , cluster = groups),
palette = c("#00AFBB","#E7B800", "#FC4E07"),
ellipse.type = "convex", # Concentration ellipse
repel = TRUE, # Avoid label overplotting (slow)
show.clust.cent = FALSE, ggtheme = theme_minimal())



```



***



Escollim on tallar el dendograma **Millor NbClust**

```{r message=FALSE, warning=FALSE}

fviz_nbclust(hfNscaled,hcut , method = "wss") +
    geom_vline(xintercept = 3, linetype = 2)+
  labs(subtitle = "Elbow method")

fviz_nbclust(hfNscaled, hcut, method = "silhouette") +
  labs(subtitle = "Silhouette method")

# fviz_nbclust(hfNscaled, hcut, nstart = 25,  method = "gap_stat", nboot = 2)+
#   labs(subtitle = "Gap statistic method")


```






Escollim 3 clusters

```{r message=FALSE, warning=FALSE}
clusters<-cutree(fitHS, k=3)

#estadistiques per cada cluster

get_pos_results(hf,clusters)

for(c in 1:3){
    cat("Cluster =",c,"\n")
    for(i in 1:13){
      cat(names(hf)[i])
      cat("\n")
      cat("mean: ",mean(hf[clusters==c,i])[1])
      cat("\n")
      cat("min: ",min(hf[clusters==c,i])[1])
      cat("\n")
      cat("max: ",max(hf[clusters==c,i])[1])
      cat("\n")
      cat("\n")
    }
}


```




```{r message=FALSE, warning=FALSE}


#plot(hf, col=clusters)

plot(fitHS)
rect.hclust(fitHS, k=3, border = "red")

fviz_dend(fitHS, k = 3, 
 k_colors = c("#1B9E77", "#D95F02", "#7570B3"))

# fviz_dend(fitHS, cex = 0.5, k = 3, color_labels_by_k = TRUE)

#fviz_cluster(fitHS2, hf, stand = FALSE, geom = "point")

```





**Calcul utilitzant funció eclust()**

```{r message=FALSE, warning=FALSE}

library(viridisLite)

#Hierarchical cluster algorithm

hc.res <- eclust(hfNscaled, "hclust", k = 2, hc_metric = "euclidean", hc_method = "ward.D2", graph = FALSE)

#Clustering visualization

fviz_dend(hc.res, show_labels = FALSE, palette = "jco", as.ggplot = TRUE)

require("cluster")

sil<-silhouette(hc.res$cluster,dist(hfNscaled))

fviz_silhouette(sil,label=FALSE,print.summary = FALSE)



```


*EXTERNAL CLUSTERING VALIDATION*

```{r message=FALSE, warning=FALSE}



#cross-tabulation entre h clus i variable death_event (EXTERNAL CLUSTERING VALIDATION)

table(hf$DEATH_EVENT, hc.res$cluster)


#Corrected Rand index (EXTERNAL CLUSTERING VALIDATION)


clust_stats <- cluster.stats(d = dist(hfscaled), 
                             hf$DEATH_EVENT, hc.res$cluster)


clust_stats$corrected.rand

clust_stats$vi

```

***








#### **2.2 Clustering jerarquic - Divisive**

Les dades han de ser numériques i han d'estar escalades


```{r message=FALSE, warning=FALSE}
#determinem el num de clusters

fviz_nbclust(hfNscaled, FUN=hcut,method = "wss")
fviz_nbclust(hfNscaled, FUN=hcut,method = "silhouette")

fviz_gap_stat(clusGap(hfNscaled,FUN=hcut,nstart=25,K.max=10, B=50))



```






```{r message=FALSE, warning=FALSE}

res.hcd<-diana(hfNscaled)

#divisive coefficient

res.hcd$dc

#dendograma

pltree(res.hcd)


```





```{r message=FALSE, warning=FALSE}
clust<-cutree(res.hcd, k=3)



fviz_cluster(list(data =hf , cluster = clust),
ellipse.type = "convex", # Concentration ellipse
repel = TRUE, # Avoid label overplotting (slow)
show.clust.cent = FALSE, ggtheme = theme_minimal())


```
Treiem observacions 10 i 218, valors que solen presentarse com outliers

```{r message=FALSE, warning=FALSE}



newhfNscaled<-hfNscaled[-c(10,218,53),]

newhf<-hf[-c(10,218,53),]



res.hcd.new<-diana(newhfNscaled)

pltree(res.hcd.new)


clust.new<-cutree(res.hcd.new, k=3)



fviz_cluster(list(data =newhf , cluster = clust.new),
ellipse.type = "convex", # Concentration ellipse
repel = TRUE, # Avoid label overplotting (slow)
show.clust.cent = FALSE, ggtheme = theme_minimal())





```




#### **3.Hierarchical + k-means **

Matriu numérica i escalada

escollirem k=2 pels resultats de NbClust

```{r message=FALSE, warning=FALSE}

res.hk <-hkmeans(hfNscaled, 2)

res.hk

```

```{r message=FALSE, warning=FALSE}

#Visualitzem el dendograma
fviz_dend(res.hk, cex = 0.6, palette = "jco",
rect = TRUE, rect_border = "jco", rect_fill = TRUE, main = "Cluster Dendogram hkmeans")


#Visualitzem els clusters fen servir les 2 primeres PCA

fviz_cluster(res.hk, palette = "jco", repel = TRUE,
ggtheme = theme_classic())

```

S'ha conseguit que no hi hagi solapació entre clusters.





#### **4.PAM **

hfscaled

```{r message=FALSE, warning=FALSE}

hfscaledR<-scale(hf[,-13])
head(hfscaledR)



```

Escollim k
```{r message=FALSE, warning=FALSE}

fviz_nbclust(hfscaled, pam, method = "wss") +
    geom_vline(xintercept = 3, linetype = 2)+
  labs(subtitle = "Elbow method")

fviz_nbclust(hfscaled, pam, method = "silhouette") +
  labs(subtitle = "Silhouette method")

# fviz_nbclust(hfscaled, pam, nstart = 25,  method = "gap_stat", nboot = 2)+
#   labs(subtitle = "Gap statistic method")


```



**Utilitzem la funció NbClust() per calcular 30 index que ens ajudarán a obtenir el número òptim de clusters (k)**
```{r message=FALSE, warning=FALSE}

res<-NbClust(hfscaled, diss=NULL, distance = "manhattan", min.nc=2, max.nc=10, method = "centroid", index = "alllong")


```




apliquem l'algoritme PAM

```{r message=FALSE, warning=FALSE}

pam.res <- pam(hfscaledR, 2, metric = "manhattan")
# print(pam.res)


clusplot(pam.res)

```

gràfic i resultats per k=2

```{r message=FALSE, warning=FALSE}
fviz_cluster(pam.res, geom = "point", ellipse.type = "norm", palette= "jco", ggtheme = theme_minimal())+labs(subtitle = "PAM")

get_pos_results(hf,pam.res$clustering)

for(c in 1:2){
    cat("Cluster =",c,"\n")
    # print(summary(hf[pam.res$clustering==c,]))
    for(i in 1:13){
      cat(names(hf)[i])
      cat("\n")
      cat("mean: ",mean(hf[pam.res$clustering==c,i])[1])
      cat("\n")
      cat("min: ",min(hf[pam.res$clustering==c,i])[1])
      cat("\n")
      cat("max: ",max(hf[pam.res$clustering==c,i])[1])
      cat("\n")
      cat("\n")
    }
    }


```












#### **5.CLARA **

```{r message=FALSE, warning=FALSE}

fviz_nbclust(hfscaled, clara, method = "wss") +
    geom_vline(xintercept = 4, linetype = 2)+
  labs(subtitle = "Elbow method")

fviz_nbclust(hfscaled, clara, method = "silhouette") +
  labs(subtitle = "Silhouette method")

# fviz_nbclust(hfscaled, clara, nstart = 25,  method = "gap_stat", nboot = 2)+
#   labs(subtitle = "Gap statistic method")

clara.res <- clara(hfscaled, 2, metric = "manhattan", stand = FALSE, 
      samples = 500, pamLike = FALSE)
print(clara.res)

fviz_cluster(clara.res, geom = "point", ellipse.type = "norm", palette= "jco", ggtheme = theme_minimal())


```
S'obtenen pitjors resultats que amb el PAM












#### **6.Mixed types: Gower distance and PAM **

Convertim en factor les variables binaries


```{r message=FALSE, warning=FALSE}
hfF<-hf

hfF$anaemia<-as.factor(hfF$anaemia)
hfF$diabetes<-as.factor(hfF$diabetes)
hfF$high_blood_pressure<-as.factor(hfF$high_blood_pressure)
hfF$sex<-as.factor(hfF$sex)
hfF$smoking<-as.factor(hfF$smoking)
hfF$DEATH_EVENT<-as.factor(hfF$DEATH_EVENT)


head(hfF)

str(hfF)


```


Gower distance

```{r message=FALSE, warning=FALSE}

gower_dist <- daisy(hfF,metric = "gower", stand=TRUE)

summary(gower_dist)



```



(surt el mateix resultat si faig servir la matriu inicial i si faig servir la matriu inicial escalada)



```{r message=FALSE, warning=FALSE}

gower_mat <- as.matrix(gower_dist)

# Els mes similars

hfF[which(gower_mat == min(gower_mat[gower_mat != min(gower_mat)]),
        arr.ind = TRUE)[1, ], ]

#Els mes diferents

hfF[which(gower_mat == max(gower_mat[gower_mat != max(gower_mat)]),
        arr.ind = TRUE)[1, ], ]

```


Seleccionem el numero de clusters

No estic segura de si esta ben aplicat el NbClust().

S'ha de fer amb la matriu numerica, la factorial no funciona.


```{r message=FALSE, warning=FALSE}

resg<-NbClust(hf, gower_dist, distance = NULL, min.nc=2, max.nc=10, method = "centroid", index = "all")


barplot(table(resg$Best.n[1,]),
              xlab="Numer of Clusters", ylab="Number of Criteria",
                    main="Number of Clusters for PAM-Gower")


table(resg$Best.n[1,])
```


silhouette width

```{r message=FALSE, warning=FALSE}

# Calculem silhouette width per a diferents k

sil_width <- c(NA)
for(i in 2:10){
  
  pam_fit <- pam(gower_dist,
                 diss = TRUE,
                 k = i)
  
  sil_width[i] <- pam_fit$silinfo$avg.width
  
}


# Plot silhouette width (com més gran millor)

plot(1:10, sil_width,
     xlab = "Number of clusters",
     ylab = "Silhouette Width")
lines(1:10, sil_width)

```
Ens surten 2 clusters com a millor opció

calculem PAM
k=2
```{r message=FALSE, warning=FALSE}

res.pam <- pam(gower_dist, diss = TRUE, k = 2)

pam_results <- hfF %>%
  mutate(cluster = res.pam$clustering) %>%
  group_by(cluster) %>%
  do(the_summary = summary(.))


pam_results$the_summary

#També podem veure l'observació que fa de centre del cluster (medoid), ens dòna informació del cluster senser

hfF[res.pam$medoids, ]

```

```{r message=FALSE, warning=FALSE}
for(c in 1:2){
    cat("Cluster =",c,"\n")
    
    for(i in 1:13){
      cat(names(hfF)[i])
      cat("\n")
      cat("mean: ",mean(hf[res.pam$clustering==c,i])[1])
      cat("\n")
      cat("min: ",min(hf[res.pam$clustering==c,i])[1])
      cat("\n")
      cat("max: ",max(hf[res.pam$clustering==c,i])[1])
      cat("\n")
      cat("\n")
    }
    }

```

k=8 POTSER NO CAL

```{r message=FALSE, warning=FALSE}

res.pam <- pam(gower_dist, diss = TRUE, k = 8)

pam_results <- hfF %>%
  mutate(cluster = res.pam$clustering) %>%
  group_by(cluster) %>%
  do(the_summary = summary(.))


pam_results$the_summary

#També podem veure l'observació que fa de centre del cluster (medoid), ens dòna informació del cluster senser

hfF[res.pam$medoids, ]

```


Una altre manera de representar-ho amb "t-distributed stochastic neighborhood embedding, or t-SNE", una tecnica de reducció de dimensió que intenta mantenir l'estructura de les dades pero de manera que es puguin visualitzar els clusters en 2D o 3D


```{r message=FALSE, warning=FALSE}

tsne_obj <- Rtsne(gower_dist, is_distance = TRUE)
tsne_data <- tsne_obj$Y %>%
  data.frame() %>%
  setNames(c("X", "Y")) %>%
  mutate(cluster = factor(res.pam$clustering))


ggplot(aes(x = X, y = Y), data = tsne_data) +
  geom_point(aes(color = cluster))


```



```{r message=FALSE, warning=FALSE}

clusplot(res.pam)

```





#### **Gràfic acumulat NbClust**


```{r message=FALSE, warning=FALSE}

#generem una taula amb els resultats de NbClust k-means, hclust i PAM-gower

acumulat<-table(cbind(reshc$Best.n[1,],resk$Best.n[1,], resg$Best.n[1,]))
#gràfic

barplot(acumulat, xlab="Numer of Clusters", ylab="Number of Criteria",
                    main="Number of Clusters (Acumulat)")


```








#### **7.K-prototypes **

```{r message=FALSE, warning=FALSE}


res.prot<-kproto(hfF, 2, lambda = NULL, iter.max = 100, nstart = 1, na.rm = TRUE)



```
```{r message=FALSE, warning=FALSE}

clprofiles(res.prot, hf)

           

```


#### **8.Model based clustering***

S'ha d'utilitzar la Matriu numèrica sense escalar

```{r message=FALSE, warning=FALSE}

hfN<-hf[,-c(2,4,6,10,11,13)]

head(hfN)

```

Comprovem que les variables tenen una distribució normal.

CPK i Creatinina en sang son les dues variables que no tenen distribució normal
```{r message=FALSE, warning=FALSE}
histogram(hf$age)
histogram(hf$creatinine_phosphokinase)
histogram(hf$ejection_fraction)
histogram(hf$platelets)
histogram(hf$serum_creatinine)
histogram(hf$serum_sodium)
histogram(hf$time)



histogram(log(hf$creatinine_phosphokinase))
histogram(log(hf$serum_creatinine))
```

També podem aplicar el test de Shapiro-Wilk per comprovar si son o no normals

```{r message=FALSE, warning=FALSE}

shapiro.test(hf$age)

shapiro.test(hf$creatinine_phosphokinase)

shapiro.test(hf$ejection_fraction)

shapiro.test(hf$platelets)

shapiro.test(hf$serum_creatinine)

shapiro.test(hf$serum_sodium)

shapiro.test(hf$time)

```
Es descarta la normalitat per a totes les variables



Convertim la matriu en logaritme per veure si es converteixen les variables en normals
```{r message=FALSE, warning=FALSE}

hfNlog<-log(hfN)

ggplot(data=hfNlog, aes(hfNlog$age)) + 
  geom_histogram()

ggplot(data=hfNlog, aes(hfNlog$creatinine_phosphokinase)) + 
  geom_histogram()

ggplot(data=hfNlog, aes(hfNlog$ejection_fraction)) + 
  geom_histogram()

ggplot(data=hfNlog, aes(hfNlog$platelets)) + 
  geom_histogram()

ggplot(data=hfNlog, aes(hfNlog$serum_creatinine)) + 
  geom_histogram()

ggplot(data=hfNlog, aes(hfNlog$serum_sodium)) + 
  geom_histogram()

ggplot(data=hfNlog, aes(hfNlog$serum_sodium)) + 
  geom_histogram()

ggplot(data=hfNlog, aes(hfNlog$time)) + 
  geom_histogram()


#Comprovem normalitat


shapiro.test(hfNlog$age)

shapiro.test(hfNlog$creatinine_phosphokinase)

shapiro.test(hfNlog$ejection_fraction)

shapiro.test(hfNlog$platelets)

shapiro.test(hfNlog$serum_creatinine)

shapiro.test(hfNlog$serum_sodium)

shapiro.test(hfNlog$time)



#Normal probability plots

qqnorm(hfNlog$age, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfNlog$age)

qqnorm(hfNlog$creatinine_phosphokinase, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfNlog$creatinine_phosphokinase)


qqnorm(hfNlog$ejection_fraction, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfNlog$ejection_fraction)



qqnorm(hfNlog$platelets, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfNlog$platelets)


qqnorm(hfNlog$serum_creatinine, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfNlog$serum_creatinine)


qqnorm(hfNlog$serum_sodium, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfNlog$serum_sodium)


qqnorm(hfNlog$time, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfNlog$time)

```
Es descarta la normalitat amb la matriu logaritmica 

Comprovem quina trasformació és mès adequada per a cada variable amb la funció bestNormalize().

```{r message=FALSE, warning=FALSE}

hfnorm<-hfN
head(hfnorm)


#Age
set.seed(67637)
bestNormalize(hf$age) #orderNorm
norm_age<-orderNorm(hf$age)
hfnorm$age<-norm_age$x.t


shapiro.test(hfnorm$age) 
qqnorm(hfnorm$age, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfnorm$age)

#S'ha normalitzat



#creatinine_phosphokinase

set.seed(67637)
bestNormalize(hf$creatinine_phosphokinase) #orderNorm
norm_cpk<-orderNorm(hf$creatinine_phosphokinase)
hfnorm$creatinine_phosphokinase<-norm_cpk$x.t

shapiro.test(hfnorm$creatinine_phosphokinase) 
qqnorm(hfnorm$creatinine_phosphokinase, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfnorm$creatinine_phosphokinase)

#S'ha normalitzat


#ejection_fraction
set.seed(67637)
bestNormalize(hf$ejection_fraction)#orderNorm

norm_ef<-orderNorm(hf$ejection_fraction)
hfnorm$ejection_fraction<-norm_ef$x.t

shapiro.test(hfnorm$ejection_fraction) 
qqnorm(hfnorm$ejection_fraction, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfnorm$ejection_fraction)

histogram(hfnorm$ejection_fraction, main="Ejection Fraction")


#No s'ha normalitzat, S'ha de factoritzar?


#platelets
set.seed(67637)
bestNormalize(hf$platelets) #orderNorm

norm_plat<-orderNorm(hf$platelets)
hfnorm$platelets<-norm_plat$x.t

shapiro.test(hfnorm$platelets) 
qqnorm(hfnorm$platelets, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfnorm$platelets)

#S'ha normalitzat


#serum_creatinine
set.seed(67637)
bestNormalize(hf$serum_creatinine)#orderNorm

norm_sc<-orderNorm(hf$serum_creatinine)
hfnorm$serum_creatinine<-norm_sc$x.t

shapiro.test(hfnorm$serum_creatinine) 
qqnorm(hfnorm$serum_creatinine, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfnorm$serum_creatinine)


histogram(hfnorm$serum_creatinine, main="Serum Creatinine")

#No s'ha normalitzat, esta al limit


#serum_sodium
set.seed(67637)
bestNormalize(hf$serum_sodium)

norm_ss<-sqrt_x(hf$serum_sodium)
hfnorm$serum_sodium<-norm_ss$x.t

shapiro.test(hfnorm$serum_sodium) 
qqnorm(hfnorm$serum_sodium, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfnorm$serum_sodium)

histogram(hfnorm$serum_sodium, main="serum sodium")
#No s'ha normalitzat


norm_ss2<-orderNorm(hf$serum_sodium)
hfnorm$serum_sodium<-norm_ss2$x.t

shapiro.test(hfnorm$serum_sodium) 
qqnorm(hfnorm$serum_sodium, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfnorm$serum_sodium)

histogram(hfnorm$serum_sodium, main="Serum sodium")

#S'ha normalitzat


#time
set.seed(67637)
bestNormalize(hf$time)

norm_t<-orderNorm(hf$time)
hfnorm$time<-norm_t$x.t

shapiro.test(hfnorm$time) 
qqnorm(hfnorm$time, 
  ylab="Standardized Residuals", 
  xlab="Normal Scores") 
qqline(hfnorm$time)

#S'ha normalitzat



```


Calcul dels models
```{r message=FALSE, warning=FALSE}

res.mc <- Mclust(hfN, G = NULL)


#No fa falta escalar res.mc1 <- Mclust(hfNscaled, G = NULL)


#No es pot  res.mc2 <- Mclust(hf, G = NULL)



#2 clusters per comparar amb els altres

res.mc3 <- Mclust(hfNscaled, G = 2)


#matriu numèrica logarítmica
res.mc4 <- Mclust(hfNlog, G = NULL)


#matriu numèrica normalitzada

head(hfnorm)

res.mc5 <- Mclust(hfnorm, G = NULL)



```



```{r message=FALSE, warning=FALSE}
#variables numeriques

summary(res.mc)
plot(res.mc, what = "density")
plot(res.mc, what = "uncertainty")

summary(res.mc$BIC)



#variables numeriques escalades - No fa falta escalar

#summary(res.mc1)
#plot(res.mc1, what = "density")
#plot(res.mc1, what = "uncertainty")

#plot(res.mc1, what = "BIC")

#summary(res.mc1$BIC)



#pel calcul amb 2 clusters - NO S'OBTENEN BONS RESULTATS

table(hf$DEATH_EVENT, res.mc3$classification)

table(hf$sex, res.mc3$classification)


#matriu numèrica logarítmica
summary(res.mc4)
plot(res.mc4, what = "density")
plot(res.mc4, what = "uncertainty")

summary(res.mc4$BIC)


#matriu numèrica normalitzada

res.mc5 <- Mclust(hfnorm, G = NULL)

summary(res.mc5)
plot(res.mc5, what = "density")
plot(res.mc5, what = "uncertainty")

summary(res.mc5$BIC)







```


```{r message=FALSE, warning=FALSE}

legend_args <- list(x = "center", ncol = 5)
plot(res.mc1, what = 'BIC', legendArgs = legend_args)


legend_args <- list(x = "center", ncol = 5)
plot(res.mc2, what = 'BIC', legendArgs = legend_args)

legend_args <- list(x = "center", ncol = 5)
plot(res.mc5, what = 'BIC', legendArgs = legend_args)


```


Apliquem MclustrDR que redueix dimensions

```{r message=FALSE, warning=FALSE}

res.mcdr1 <- MclustDR(res.mc1, lambda = 1)

summary(res.mcdr1)


#2 clusters

res.mcdr3 <- MclustDR(res.mc3, lambda = 1)

summary(res.mcdr3)



res.mcdr5 <- MclustDR(res.mc5, lambda = 1)

summary(res.mcdr5)



```

```{r message=FALSE, warning=FALSE}

plot(res.mcdr1, what = "contour")


plot(res.mcdr3, what = "contour")

plot(res.mcdr5, what = "contour")




plot(res.mcdr1, what = "boundaries", ngrid = 200)

plot(res.mcdr3, what = "boundaries", ngrid = 200)

plot(res.mcdr5, what = "boundaries", ngrid = 200)


```

Convertim en logaritme CPK i Creatinina en sang

```{r message=FALSE, warning=FALSE}

hfNlog2<-hfN

hfNlog2$creatinine_phosphokinase<-log(hfNlog$creatinine_phosphokinase)
hfNlog2$serum_creatinine<-log(hfNlog$serum_sodium)


```

```{r message=FALSE, warning=FALSE}

res.mc6 <- Mclust(hfNlog2, G = NULL)

summary(res.mc6)
plot(res.mc6, what = "density")
plot(res.mc6, what = "uncertainty")

plot(res.mc6, what = "BIC")

summary(res.mc6$BIC)


```





#### **9.Fuzzy clustering **

Matriu numèrica i escalada també es pot utilitzar el resultat de la distancia de gower

```{r message=FALSE, warning=FALSE}
res.fanny <- fanny(hfNscaled, 2)


fviz_cluster(res.fanny, ellipse.type = "norm", repel = TRUE,
palette = "jco", ggtheme = theme_minimal(),
legend = "right")

```



```{r message=FALSE, warning=FALSE}
res.fanny2 <- fanny(gower_dist, diss = TRUE, k = 2)

clusplot(res.fanny2)


```

Evaluem el resultat


```{r message=FALSE, warning=FALSE}

fviz_silhouette(res.fanny, palette = "jco",
ggtheme = theme_minimal())


fviz_silhouette(res.fanny2, palette = "jco",
ggtheme = theme_minimal())

```









###Anàlisi de clusters estratificat


####**Homes/Dones**



Construcció matrius 

```{r message=FALSE, warning=FALSE}
hfH<-hf[hf$sex==1,]

hfD<-hf[hf$sex==0,]


```

Numeriques i escalades
```{r message=FALSE, warning=FALSE}
hfHNscaled<- scale(hfH[,-c(2,4,6,10,11,13)])

hfDNscaled<- scale(hfD[,-c(2,4,6,10,11,13)])

head(hfDNscaled)

```

k-means

**Utilitzem la funció NbClust() per calcular 30 index que ens ajudarán a obtenir el número òptim de clusters**
```{r message=FALSE, warning=FALSE}

res<-NbClust(hfDNscaled, diss=NULL, distance = "euclidean", min.nc=2, max.nc=10, method = "kmeans", index = "alllong")



barplot(table(res$Best.n[1,]),
              xlab="Numer of Clusters", ylab="Number of Criteria",
                    main="Number of Clusters Chosen by 28 Criteria")
table(res$Best.n[1,])


```

```{r message=FALSE, warning=FALSE}

tic()

res<-NbClust(hfHNscaled, diss=NULL, distance = "euclidean", min.nc=2, max.nc=10, method = "kmeans", index = "alllong")

toc()


barplot(table(res$Best.n[1,]),
              xlab="Numer of Clusters", ylab="Number of Criteria",
                    main="Number of Clusters Chosen by 28 Criteria")
table(res$Best.n[1,])


```

k-means k = 2

```{r message=FALSE, warning=FALSE}

#K-means algorithm

km.resDNs <-eclust(hfDNscaled, "kmeans", k=2, nstart=50, graph = F )

#Clustering visualization

fviz_cluster(km.resDNs, geom = "point", ellipse.type = "norm", palette= "jco", ggtheme = theme_minimal())
```

pam k = 2

```{r message=FALSE, warning=FALSE}

#pam algorithm

pam.resDNs<-eclust(hfDNscaled, "pam", k=2, nstart=50, graph = F )

#Clustering visualization

fviz_cluster(pam.resDNs, geom = "point", ellipse.type = "norm", palette= "jco", ggtheme = theme_minimal())
```








Per homes

**hkmeans**

```{r message=FALSE, warning=FALSE}

#K-means algorithm

# Treiem posible outlier

hfHNscaledwoOutliers <- hfHNscaled[!(row.names(hfHNscaled) %in% c("10")),]

hk.resHNs1 <- hkmeans(hfHNscaledwoOutliers, k=2)
hk.resHNs2 <- hkmeans(hfHNscaled, k=2)


#Clustering visualization

plothk.resHNs1 <- fviz_cluster(hk.resHNs1, palette = "jco", repel = TRUE, ggtheme = theme_classic(),main = "Homes sense obs. 10")
plothk.resHNs2 <- fviz_cluster(hk.resHNs2, palette = "jco", repel = TRUE, ggtheme = theme_classic(),main = "Homes")



```

Per dones

**hkmeans**

```{r message=FALSE, warning=FALSE}

#K-means algorithm

# Treiem posibles outliers

hfDNscaledwoOutliers <- hfDNscaled[!(row.names(hfDNscaled) %in% c("53","218")),]

hk.resDNs1 <- hkmeans(hfDNscaledwoOutliers, k=2)
hk.resDNs2 <- hkmeans(hfDNscaled, k=2)


#Clustering visualization

plothk.resDNs1 <- fviz_cluster(hk.resDNs1, palette = "jco", repel = TRUE, ggtheme = theme_classic(),main = "Dones sense obs. 53 and 218")
plothk.resDNs2 <- fviz_cluster(hk.resDNs2, palette = "jco", repel = TRUE, ggtheme = theme_classic(),main = "Dones",)


#Funció que calcula hkmeans i mostra el resultat

study_hkmeans(hfDNscaled,2,c("53","218"),title = "Dones",titleoutliers = "Dones sense obs. 53 i 218")

```


```{r message=FALSE, warning=FALSE}

plothk.resDNs1 + plothk.resHNs2

```




####**Morts/Vius**

```{r message=FALSE, warning=FALSE}

#morts
hfM<-hf[hf$DEATH_EVENT==1,]
#vius
hfV<-hf[hf$DEATH_EVENT==0,]

hfMNscaled<- scale(hfM[,-c(2,4,6,10,11,13)])

hfVNscaled<- scale(hfV[,-c(2,4,6,10,11,13)])


#Funció que calcula hkmeans i mostra el resultat
study_hkmeans(hfMNscaled,2,title = "Morts")

study_hkmeans(hfVNscaled,2,title = "Vius")


```


####***EF estratificat***



```{r message=FALSE, warning=FALSE}

#construim matriu amb la variable EF estratificada segons classificació AHA

hfEF<-hf

hfEF$ejection_fraction <-replace(hfEF$ejection_fraction,hfEF$ejection_fraction>=50,"Normal")
hfEF$ejection_fraction <-replace(hfEF$ejection_fraction,(hfEF$ejection_fraction>=41 & hfEF$ejection_fraction<50),"Limit")
hfEF$ejection_fraction <-replace(hfEF$ejection_fraction,hfEF$ejection_fraction<41,"Reduida")

hfEFNormal<-hfEF[hfEF$ejection_fraction == "Normal",]
hfEFLimit<-hfEF[hfEF$ejection_fraction == "Limit",]
hfEFReduida<-hfEF[hfEF$ejection_fraction == "Reduida",]

hfEFNormalNscaled <- scale(hfEFNormal[,-c(2,4,5,6,10,11,13)])

hfEFLimitNscaled <- scale(hfEFLimit[,-c(2,4,5,6,10,11,13)])

hfEFReduidaNscaled <- scale(hfEFReduida[,-c(2,4,5,6,10,11,13)])


#Funció que calcula hkmeans i mostra el resultat

study_hkmeans(hfEFNormalNscaled,2,title = "EF Normal > 50",titleoutliers = "EF Normal > 50 w/o obs. 53 and 218" ,outliers = c("53","218"))

study_hkmeans(hfEFLimitNscaled,2,title = "EF Limit entre 41 i 50")

study_hkmeans(hfEFReduidaNscaled,2,title = "EF Reduida < 41")

study_hkmeans(hfEFReduidaNscaled,2,title = "EF Reduida < 41",titleoutliers = "EF Reduida < 41 w/o obs. 10" ,outliers = c("10"))

```

####**Anàlisi matriu factoritzada (Gower distance)**

####**Homes/Dones**

```{r message=FALSE, warning=FALSE}
#Tornem a construir les matrius a partir de la factoritzada (variables binàries com a factor per poder calcular la distancia de Gower)

hfFH<-hfF[hfF$sex==1,]
hfFD<-hfF[hfF$sex==0,]

hfH<-hf[hf$sex==1,]
hfD<-hf[hf$sex==0,]

#Eliminem la variable estratificada

hfFHwoSex = subset(hfFH,select=-c(sex))
hfHwoSex = subset(hfH,select=-c(sex))

hfFDwoSex = subset(hfFD,select=-c(sex))
hfDwoSex = subset(hfD,select=-c(sex))

res.study <- study_gow_sil(hfFHwoSex,hfHwoSex,mink = 2,maxk = 10)

#gow.dis.d <- study_go_nbc(hfFDwoSex,hfDwoSex) NO FUNCIONA, MATRIU SINGULAR (ILL CONDITIONED)

##Funció que calcula PAM amb Gower distance i mostra el resultat

study_pam_gow(hfFHwoSex,res.study[[1]],k = res.study[[2]],titulo = "PAM GOWER Factor Homes")


```


####**Vius/Morts**

```{r message=FALSE, warning=FALSE}
#Tornem a construir les matrius a partir de la factoritzada (variables binàries com a factor per poder calcular la distancia de Gower)

hfFM<-hfF[hfF$DEATH_EVENT==1,]
hfFV<-hfF[hfF$DEATH_EVENT==0,]

hfM<-hf[hf$DEATH_EVENT==1,]
hfV<-hf[hf$DEATH_EVENT==0,]


#Eliminem la variable estratificada
hfFMwoDE = subset(hfFM,select=-c(DEATH_EVENT))
hfMwoDE = subset(hfM,select=-c(DEATH_EVENT))

hfFVwoDE = subset(hfFV,select=-c(DEATH_EVENT))
hfVwoDE = subset(hfV,select=-c(DEATH_EVENT))





res.m <- study_gow_sil(hfFMwoDE,hfMwoDE, 2, 10)
res.v <- study_gow_sil(hfFVwoDE,hfVwoDE, 2, 10)

study_pam_gow(hfFMwoDE,res.m[[1]],k = res.v[[2]],titulo = "PAM GOWER Factor Morts")
study_pam_gow(hfFVwoDE,res.v[[1]],k = res.v[[2]],titulo = "PAM GOWER Factor Vius")


```







#### **2. **





$$\boldsymbol{y_{ij} = \mu + \alpha_i + \epsilon_{ij}}$$




#### **3.  **

\underline{Media}

***mean()***.
```{r warning=FALSE,message=FALSE}


```










